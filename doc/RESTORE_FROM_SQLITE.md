# Restoring from a SQLite dump file

rqlite supports loading a node directly from a SQLite dump file. This is a fast and efficient manner to initialize a system from an existing SQLite database, or to restore from an existing [node backup](https://github.com/rqlite/rqlite/blob/master/doc/BACKUPS.md). An example restore is shown below.

## Example
The following example shows a trivial database being generated by `sqlite3`, the SQLite file being backed up, converted to the corresponding list of SQL commands, and then loaded into a rqlite node listening on localhost. _Be sure to set the Content-type header as shown._
```bash
~ $ sqlite3 restore.sqlite
SQLite version 3.14.1 2016-08-11 18:53:32
Enter ".help" for usage hints.
sqlite> CREATE TABLE foo (id integer not null primary key, name text);
sqlite> INSERT INTO "foo" VALUES(1,'fiona');
sqlite>
~ $ echo '.dump' | sqlite3 restore.sqlite > restore.dump # Convery SQLite database file to set of SQL commands.
~ $ curl -XPOST localhost:4001/db/load -H "Content-type: text/plain" --data-binary @restore.dump
```
**Note that you must convert the backup file (in this example `restore.sqlite`) to the list of SQL commands**. You cannot restore using SQLite backup file.

Let's connect to the node, and check that the data has been loaded correctly.
```bash
$ rqlite
127.0.0.1:4001> SELECT * FROM foo
+----+-------+
| id | name  |
+----+-------+
| 1  | fiona |
+----+-------+
```

The behavior of the restore operation when data already exists on the node is undefined. Also, please **note that SQLite dump files normally contain a command to disable Foreign Key constraints**. If you wish to re-enable Foreign Key constraints after the load operation completes, check out [this documentation](https://github.com/rqlite/rqlite/blob/master/doc/FOREIGN_KEY_CONSTRAINTS.md).
